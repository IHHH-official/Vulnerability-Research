# MOVEit Transfer SQL Injection Vulnerability

## 작성자

이연제

## 발생일자

2023.05

## Summary

MOVEit Transfer 2021.0.6(13.0.6), 2021.1.4(13.1.4), 2022.0.4(14.0.4), 2022.1.5(14.1.5), 2023.0.1(15.0.1)과 그 이전 버전에서 SQL Injection 취약점이 발견되고, 해당 취약점을 통해 권한이 없는 공격자가 해당 DB에 접근 및 데이터 도용 가능해짐

- Max CVSS : 9.8
- EPSS : 95.23%

## Keyword

#CVE-2023-34362 #SQLInjuction #MOVEit #zeroday

## Root Cause

- MOVEit Transfer : 관리형 파일 전송(MFT, Managed File Transfer) 소프트웨어 제품

  - 이때 SQL 데이터베이스를 통해서 정보 저장 및 관리
  - MOVEit Transfer 설치 과정에서 SQL 서버 세부 사항 지정 => MOVEit Transfer를 통해 사용자, 그룹, 권한, 설정, 파일 전송 기록 등에 대한 정보를 SQL 데이터베이스에 저장 및 검색 가능

- patch되기 이전과 이후 비교

  1. *UserGetUsersWithEmailAddress()*에서 문자열을 SQL 빌더 유틸리티로 전달하여 SQL 쿼리를 보다 안전하게 업데이트

  ```C#
  // before patch

  private void UserGetUsersWuthEmailAddress(ref ADIRecirdest MyRS, string EnamilAddress, string InstID, bool bJustEndUsers = false, ... )
  {
    Type type = typeof(string);
    object[] objArray = new object[] { ... }
    object[] objArray1 = objArray;
    bool[] flagArray = new bool[] { false, true, false, true };
    bool[] flagArray1 = flagArray;
    object obj = NewLateBinding.LateGet(null, type, "Format", objArray, null, null, flagArray);
    if (flagArray1[1])
    {
      InstID = (string)Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray1[1], typeof(string)));
    }
    if (flagArray1[3])
    {
      // 가려진 정보
    }
  }
  ```

  ```C#
  // after patch

  private void UserGetUsersWithEmailAddress(red IRecoedset MyRS, string EmailAddress, string InstID, bool bJustEndUsers = false, ... )
  {
    Func<string, string> func = new Func<string, string>(this.siGlobs.onjWrap.Connection.FormatParameterName);
    SQLBasicBuilder where = this._sqlBuilderUsers.SelectBuilder().AddColumnsToSelect(new string[] {"Username", "Permission", "LoginName", ... })
    if (bJustEndUsers)
      // 가려진 정보
    {
      where.AddAndColumnGreaterThanToWhere<int>("Permission", 10, true, false);
    }
    string str = this.siGlobs.objUtility.BuildLikeForSQL(EmailAddress);
    List<string> strs = new List<string>()
    {
      string.Format("Email={0}", func("Email")),
      this.siGlobs.objUtility.BuildLikeForSQL("Email", func("FirstEmail"), true, false, false, false)
    };
    where.WithParameter("Email", EmailAddress);
    where.WithParameter("FirstEmail", string.Format("{0},%", str));
    if(!bJustFirstEmail)
    {
      str.Add(this.siGlobs.objUtility.BuildLikeForSQL("Email", func("MiddleEmail"), true, false, false, false));
      str.Add(this.siGlobs.objUtility.BuildLikeForSQL("Email", func("LastEmail"), true, false, false, false));
      where.WithParameter("MiddleEmail", string.Format("%,{0},%", str));
      where.WithParameter("LastEmail", string.Format("%,{0}", str));
    }
    where.AddAndToWhere(string.Concat("(", string.Join(" OR", strs), ")"));
    where.AddColumnToOrderBy("LoginName", SQLBasicBuilder.OrderDirection.Ascending);
    this.siGlobs.objWrap.DoReadQuery(where.GetQuery(where.GetQuery(), where.Parameter, ref MyRS, true, false);
  }
  ```

  - 패치 전 코드 : _LateGet_ 메소드를 이용해 사용자로부터의 입력 (ex. InstID, EmailAddress 등)을 SQL 쿼리에 직접 삽입 가능 => 악의적인 입력으로 데이터베이스 내 정보 조작 및 탈취 가능
  - 패치 후 코드
    - _NewLateBinding.LateGet_ 메소드에서 파라미터화된 쿼리를 사용해 쿼리 생성 방법 변경
    - _where.WithParameter_ 메소드를 활용하여 SQL 쿼리 파라미터 설정 => 사용자 입력으로 인한 SQL Injuction 방지 가능
    - _this.siGlobs.objUtility.BuildLikeForSQL_ 메소드를 통해 사용자가 입력한 문자열을 SQL의 LIKE 연산자에서 사용가능한 안전한 형태로 변경

  2. _SetAllSessionVarsFromHeaders()_ 삭제

  ```c#
  public bool SetAllSessionVarsFromHeaders(string SeverVars)
  {
    bool falg = true;
    string[] strArrays = String.Split(ServerVars, "\r\n", -1, CompareMethod.Binary);
    int num = String.Len("X-siLock-SessVar");
    int num1 = Information.LBound(strArrays, 1);
    int num2 = Information.UBound(strArrays, 1);
    for (int i = num1; i < num2; i = checked(i + 1))
    {
      if (Operaotrs.CompareString(Strings.Left(strArrays[i], num), "X-siLock-SessVar", false) == 0)
      {
        int num3 = strArrays[i].IndexOf(':', num);
        if (num3 >= 0)
        {
          int num4 = strArrays[i].IndexOf(':', checked(1 + num3));
          if (num4 > 0)
          {
            string str = strArrays[i].Substring(checked(2 + num3), checked(checked(num4 - num3) - 2));
            string str1 = strArrays[i].Substring(checked(2 + num4));
            this.SetValue(str, str1);
          }
        }
      }
    }
  }
  ```

  - 해당 코드에서는 입력값에 대한 검증 수행 X
    - ex) _strArrays[i].Substring_ 메소드 사용하여 문자열 분열 시 인덱스 범위 확인이나 예외 처리 X => \*_ArgumentOutOfRangeException_ 발생 가능

  3. *GetFileUploadInfo()*에 _uploadState_ 추가

  ```c#
  private bool GetFileUpload()
  {
    string tableNameAttribute = SqlTable.FileUploadInfo.GetTableNameAttribute();
    string str = SqlTable.Files.GetTableNameAttribute();
    SILDictionary<string, string> sILDictionary = (new SQLBasicBuilder(this._globaels.objWarp, SqlTable.FileUploadInfo)).AddColumnToSelect( ... );
    if (sILDictionary == null)
    {
      this.SetParameterError(0xed8, 0x16190, this._field);
      return false;
    }
    this._originalUploadComment = this._globals.objUtility.DBFieldDecrypt(sILDictionary["Comment"]);
    this._xferld = long.Parse(sILDictionary["XferID"]);
    string item = sILDictionary["State"];
    // 추가된 코드
    this._uploadState = (string.IsNullOrEmpty(itemp ? Array.Empty<byte>() : Encryption.DecryptBytesForDatebase(item, this._orgld)));
    return true;
  }
  ```

  - *DecryptBytesForDatabase*를 통해 복호화하기 전에 *state*가 NULL인지 판단

## Exploit

- 2023년 5월 27일에 웹 쉘 배포 및 데이터 도난 발생
- UNC4857의 소행으로 짐작
- 해당 제로데이 공격 당한 조직은 핸섬웨어 이메일 받았음을 확인

  - MOVEit Transfer 구성요소인 *human.aspx*로 가장한 파일을 가진 **LEMURLOOT 웹 쉘** 배포
  - LEMURLOOT : MOVEit Transfer와 상호작용하도록 C#으로 작성된 웹 쉘

    - 하드코딩된 비밀번호 통해 들어오는 연결 인증 및 MOVEit Transfer 설치한 시스템에서 파일 다운로드, 애저 시스템 설정 추출, 기록 정보 검색, 특정 사용자 생성/삽입/삭제 명령어 실행 가능
    - LERMURLOOT는 먼저 들어오는 HTTP 요청에 헤더 필드 *X-siLock-Comment*와 샘플에 따라 달라지는 36자 _GUID_ 형식 값 포함됐는지 확인
    - 해당 *GUID*를 비밀번호로 사용 및 예상 헤더 필드와 값 전달하지 않는 클라이언트에는 404 상태 코드 반환
    - 올바른 비밀번호 전달 시 연결 성공해 작업 수락할 수 있음을 나타내는 헤더 응답 *X-siLock-Comment*와 값 주석 보냄
    - 해당 멀웨어는 _SystemSetting.DatabaseSettings()_ 사용해 검색 설정으로 실행 호스트에 SQL 서버 연결
    - 연결된 클라이언트가 수행한 데이터 처리 후 HTTP 헤더 필드(X-siLock-Step1, X-siLock-Step2, X-siLock-Step3)에 예상되는 명령 구문 분석
      - X-siLock-Step1
        - 헤더 필드 값이 -1인 경우 해당 멀웨어는 애저 시스템 설정을 MOVEit Transfer에서 검색 후 반환. 그 후 SQL 쿼리 수행하여 파일, 파일크기, 폴더, 파일 소유자 및 교육기관 이름 데이터 검색하여 결과 데이터를 gzip으로 압축
        - 헤더 필드 값이 -2인 경우 `DELETE FROM users WHERE RealName='Health Check Service` 수행하여 사용자 계정 삭제
      - X-siLock-Step2, 3
        - X-siLock-Step2 헤더 필드 값이 -1, -2가 아닌 경우 해당 멀웨어는 X-siLock-Step2, X-siLock-Step3의 값 파싱하여 _fileid_ 및 *folderif*라는 변수에 저장
          - 해당 변수들의 값이 null이 아닌 경우 로컬 MOVEit Transfer에서 동일 값 검색 및 gzip으로 압축
          - 해당 변수들의 값이 null인 경우
            - 멀웨어는 권한수준이 30이고 *InstID="X-siLock-Step1"*에서 설정된 값으로 기존 계정 식별 시도
            - 위의 케이스가 아닌 경우 사용자 이름과 LoginName, RealName이 "Health Check Service"로 설정된 새 계정 생성

  - LEMURLOOT와 상호작용 전 합벅적 파일인 _guestaccess.aspx_ 파일에 대한 POST 요청있었으며 이는 SQLi 공격이 해당 파일로 향했음을 보여줌

## References

[CVEdetails](https://www.cvedetails.com/cve/CVE-2023-34362/)<br>
[Prgress Comunity](https://community.progress.com/s/article/MOVEit-Transfer-Critical-Vulnerability-31May2023) <br>
[MANDIANT](https://www.mandiant.kr/resources/blog/zero-day-moveit-data-theft) <br>
[Horizon3.ai](https://www.horizon3.ai/moveit-transfer-cve-2023-34362-deep-dive-and-indicators-of-compromise/) <br>

## confer

1. 2023년 CVE에 가장 많이 보고된 취약점 타입은 *Memory Corruption*과 *SQL Injuction*이며, impact type으로는 *Code Execution*과 *Information Leak*이다 <br>[CVEdetails](https://www.cvedetails.com/vulnerabilities-by-types.php)

2. 관련 용어 정리 [보안뉴스](https://www.boannews.com/media/view.asp?idx=82171)

- CVSS : 해당 점수가 높을수록 빠르게 취약점 패치해야함 <br>
  - 7점이 넘어가면 위험한 취약점이라 판단해야하지만 상당수의 취약점이 7점이 넘어가기 때문에 이를 매번 패치하는 데에는 한계가 존재할 수 있음
- EPSS : Exploit Prediction Scoring System, 10자지 이상의 요소들을 반영하여 해당 취약점이 실제로 공격 활용성이 있는지 판단
  - 단위는 %로 100에 가까울수록 공격 활용성이 높음
