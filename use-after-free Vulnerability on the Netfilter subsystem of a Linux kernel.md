# use-after-free Vulnerability on the Netfilter subsystem of a Linux kernel

## 작성자

이연제

## 발생일자

## Summary

Linux 커널의 Netfilter 하위 시스템에서 use-after-free 취약점이 발견됨. 해당 취약점을 통해 사용자 접근 권한이 있는 로컬 공격자가 권한 상승을 시도할 수 있게 됨.
[공격 영상](https://www.youtube.com/watch?v=YqmwA6fPjKE)

- Max CVSS : 7.8
- EPSS : 54% 이하

## Keyword

#Linux #Netfilter #CVE-2022-32250 #privilege-escalation #use-after-free #memory-corruption

## Root Cause

- Netfilter : 리눅스 커널 프레임워크. 사용자 정의 핸들러 사용하여 네트워킹 관련 작업 구현
  - 네트워크 스택 내에서 패킷이 이동하는 여러 지점에 콜백을 등록하는 것을 비롯해 주소나 포트 변경, 패킷 drop, 로깅 등과 같이 패킷 상의 다양한 동작을 수행할 수 있는 프레임워크 제공
  - `nftable` : 아래 4가지를 통해 명령어 저장 및 처리
    - `tables` : 여러 `chains` 포함 및 `IP`나 `IP6`과 같은 프로토콜들과 연결됨
    - `chains` : 여러 `rules`과 처리할 네트워크 트래픽 정보의 유형 포함
    - `rules` : 여러 `expression` 포함 및 `chain`이 수신하는 체인 내부 규칙으로 평가됨
    - `expressions` : input이 일련의 조건에 만족하는지 평가 <br>
      [vulnerability of nftable](https://blog.dbouman.nl/2022/04/02/How-The-Tables-Have-Turned-CVE-2022-1015-1016/)

## Exploit

### use-after-free(UAF) : 프로그램 수행 중 이미 free된 메모리 위치에 접근하려고 할 때 발생하는 temporal memory error. 즉 Memory Corruption의 일종

- `nftable`에 `NFT_MSG_NEWSET` 명령어 추가 시 발생
- `lookup`과 `dynset` 표현식 처리 과정에서 free chunk가 잘못된 `NFT_STATEFUL_EXPR` 체크로 인해 `set->binding`리스트에 남게 되고, 이로 인해 use-after-free 에러 발생

- `nft_expr_init`에서 `nf_tables_expr_parse`를 호출하고 메모리에 `expr`를 위한 공간이 할당됨. 그 후 `nf_tables_newexpr`는 `expr` 초기화

```c
static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,
                      const struct nlattr *nla)
{
    struct nft_expr_info expr_info;
    struct nft_expr *expr;
    struct module *owner;
    int err;

    err = nf_tables_expr_parse(ctx, nla, &expr_info);
    if (err < 0)
        goto err1;

    err = -ENOMEM;
    expr = kzalloc(expr_info.ops->size, GFP_KERNEL);
    if (expr == NULL)
        goto err2;

    err = nf_tables_newexpr(ctx, &expr_info, expr);
    if (err < 0)
        goto err3;

    return expr;
err3:
    kfree(expr);
err2:
    owner = expr_info.ops->type->owner;
    if (expr_info.ops->type->release_ops)
        expr_info.ops->type->release_ops(expr_info.ops);

    module_put(owner);
err1:
    return ERR_PTR(err);
}
```

- `expr` 타입에 따라 적절한 structure가 `data[]`에 저장됨
  <br>
  <br>
  <br>
- `nf_tables_newexpr`는 `expr`의 `ops`를 참조하여 `ops->init`을 호출. `lookup`의 경우 `ops->init`은 `nft_lookup_init`을 포함

```c
static int nf_tables_newexpr(const struct nft_ctx *ctx,
                 const struct nft_expr_info *expr_info,
                 struct nft_expr *expr)
{
    const struct nft_expr_ops *ops = expr_info->ops;
    int err;

    expr->ops = ops;
    if (ops->init) {
        err = ops->init(ctx, expr, (const struct nlattr **)expr_info->tb);
        if (err < 0)
            goto err1;
    }

    return 0;
err1:
    expr->ops = NULL;
    return err;
}
```

- `expr_init`인 표현식 정보를 통해 새로운 표현식 `expr`를 초기화. `ops->init` 존재하는 경우 이를 호출하고, 에러 발생하는 경우 `err1`으로 가서 `expr->ops`를 NULL로 설정하고 에러 반환 <br>
  <br>
- `nft_lookup_init`의 경우 `nf_tables_bind_set`을 호출하며 `nf_tables_bind_set`는 `set->binding`에서 `expr`를 바인딩.

```c
static int nft_lookup_init(const struct nft_ctx *ctx,
               const struct nft_expr *expr,
               const struct nlattr * const tb[])
{
    struct nft_lookup *priv = nft_expr_priv(expr);
    u8 genmask = nft_genmask_next(ctx->net);
    struct nft_set *set;
    u32 flags;
    int err;

    if (tb[NFTA_LOOKUP_SET] == NULL ||
        tb[NFTA_LOOKUP_SREG] == NULL)
        return -EINVAL;

    set = nft_set_lookup_global(ctx->net, ctx->table, tb[NFTA_LOOKUP_SET],
                    tb[NFTA_LOOKUP_SET_ID], genmask);
    if (IS_ERR(set))
        return PTR_ERR(set);

    ...

    priv->binding.flags = set->flags & NFT_SET_MAP;

    err = nf_tables_bind_set(ctx, set, &priv->binding);
    if (err < 0)
        return err;

    priv->set = set;
    return 0;
}

int nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,
               struct nft_set_binding *binding)
{
    struct nft_set_binding *i;
    struct nft_set_iter iter;

    if (set->use == UINT_MAX)
        return -EOVERFLOW;

    if (!list_empty(&set->bindings) && nft_set_is_anonymous(set))
        return -EBUSY;

    ...

bind:                                                       // [1] bind expr to set->binding
    binding->chain = ctx->chain;
    list_add_tail_rcu(&binding->list, &set->bindings);
    nft_set_trans_bind(ctx, set);
    set->use++;

    return 0;
```

- `set`에 `binding`을 추가
- set의 사용량(`use`)이 `UNIT_MAX` 초과 시 `-EOVERFLOW` 반환.
- `set`이 익명이고, 이미 바인딩 있으면 `-EBUSY` 반롼
- 위의 경우가 아닌 경우 `binding`에 `chain` 설정하고, `set`의 `binding` 추가(`set`에 `expr` 바인딩) 및 `set` 사용량 증가
- `nft_expr_init` 실행 완료 시 호출자인 `nft_set_elem_expr_alloc`으로 돌아감. 만약 `expr->ops->type->flags`가 `NFT_EXPR_STATEFUL`이 아니면, `err_set_elem_expr`로 이동하여 `nft_expr_destroy` 호출하여 `set`에 추가된 표현식 제거 => **해당 과정에서 제거되지 않아야 할 표현식이 제거되는 것이 취약점의 원인**

## Patch

```
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 12fc9cda4a2cf..f296dfe86b622 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -2873,27 +2873,31 @@ static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx,

    err = nf_tables_expr_parse(ctx, nla, &expr_info);
    if (err < 0)
-       goto err1;
+       goto err_expr_parse;
+
+   err = -EOPNOTSUPP;
+   if (!(expr_info.ops->type->flags & NFT_EXPR_STATEFUL))
+       goto err_expr_stateful;

    err = -ENOMEM;
    expr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT);        // Commit kernel version is higher.
    if (expr == NULL)                                               // So it just written as GFP_KERNEL_ACCOUNT
-       goto err2;
+       goto err_expr_stateful;

    err = nf_tables_newexpr(ctx, &expr_info, expr);
    if (err < 0)
-       goto err3;
+       goto err_expr_new;

    return expr;
-err3:
+err_expr_new:
    kfree(expr);
-err2:
+err_expr_stateful:
    owner = expr_info.ops->type->owner;
    if (expr_info.ops->type->release_ops)
        expr_info.ops->type->release_ops(expr_info.ops);

    module_put(owner);
-err1:
+err_expr_parse:
    return ERR_PTR(err);
 }

@@ -5413,9 +5417,6 @@ struct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,
        return expr;

    err = -EOPNOTSUPP;
-   if (!(expr->ops->type->flags & NFT_EXPR_STATEFUL))
-       goto err_set_elem_expr;
-
    if (expr->ops->type->flags & NFT_EXPR_GC) {
        if (set->flags & NFT_SET_TIMEOUT)
            goto err_set_elem_expr;
```

## References

[Theori](https://blog.theori.io/linux-kernel-exploit-cve-2022-32250-with-mqueue-a8468f32aab5})<br>
[Linux Kernel Netfilter](https://pr0gr4m.github.io/linux/kernel/netfilter/) <br>
[CVE Details](https://www.cvedetails.com/cve/CVE-2022-32250/) <br>
[유똥's blog](https://yuttong.tistory.com/244) <br>
[RedHat](https://access.redhat.com/security/cve/cve-2022-32250) <br>
