# Google Chrome V8 Type Confusion Vulnerability

## 작성자

이연제

## 발생일자

2023.04

## Summary

구글 크롬 V8에 type confusion 취약점이 존재했으며 이는 잠재적으로 공격자가 조작된 HTML 페이지를 통해 힙 손상을 악용할 수 있다.

## Keyword

#CVE-2023-2033 #Google #Chrome #TypeConfusion #bypass

## Root Cause

### V8

- Google Chrome과 Node.js에서 사용하는 구글에서 제작한 자바스크립트 엔진
- C++로 작성. 고성능의 자바스크립트 전용 웹 어셈블리 엔진
- 일반적인 자바스크립트 엔진이 인터프리터 형식이라면 V8 엔진은 자바스크립트 코드를 바이트코드로 컴파일하고 실행
- **_샌드박스_** : 같은 컴퓨터 내에서 다른 환경과 분리되어 파이션이 지정된 소프트웨어를 실행할 수 있는 환경

  - V8의 핵심 기능
  - 각 프로세스에는 샌드박스가 적용되어 자바스크립트 함수가 개별적으로 실행되고 한 코드의 실행이 다른 코드에 영향을 끼치지 않음

- 웹어셈블리에서의 3가지 개념
  1. 모듈 : 자바스크립트를 사용하여 인스턴스화 할 수 있는 상태가 없는 웹어셈블리 코드의 집합
  2. 인스턴스 : 모듈에서 생성된 상태가 있는 실행 가능한 객체
  3. **테이블** : 테이블 인덱스를 통해 함수에 접근할 수 있는 함수의 배열 -> 웹어셈블리 코드나 자바스크립트 API에 의해 동적으로 읽고 쓸 수 있음
  - V8에서 웹어셈블리 인스턴스와 테이블은 `WasmInstanceObject`와 `WasmTableObject`로 구현되고, `WasmIndirectFunctionTable`이 할당되고, 이는 `WasmInstanceObject`와 `_function_tablse` 필드에 저장. `WasmIndirectFunctionTable`에는 `WasmTableObject` 함수 포인터가 포함된 `targets` 필드 존재. JaveScript 함수는 `WasmInstanceObject`의 `imported_function_targets` 필드에 저장.

## Exploit

- `WasmIndirectFunctuinTable`를 사용하여 임의의 쓰기 원시 데이터 얻는 방법

  - `WasmindirectFunctionTable`의 메모리를 덤프하면 `targets`가 V8 샌드박스 외부 메모리 영역을 가리키는 원시 포인터임을 알 수 있음
  - `targets` 포인터에 접근하는 코드를 찾으면 `WasmindirectFunctionTable`이라는 함수 찾을 수 있음

  ```c++
  void WasmIndirectFunctionTable::Set(uint32_t index, int sig_id,Address call_target, Object ref) {
      sig_ids()[index] = sig_id;
      targets()[index] = call_target;
      refs().set(index, ref);
  }
  ```

  - 해당 함수는 `call_target`을 `targets`가 가리키는 메모리 영역에 작성
  - `targets`는 V8 샌드박스 내 원시 포인터이므로, 샌드박스 내의 읽기&쓰기 원시 데이터를 수정하여 임의의 쓰기 원시 데이터 얻을 수 있음

- 임의의 쓰기 원시 데이터를 얻는 방법
  1. 웹어셈블리 테이블과 테이블을 가져오는 웹어셈블리 생성
     - 웹어셈블리 모듈은 `native_module->num_imported_functions()`가 0이 아닌 값을 만들기 위해 최소한 하나의 자바스크립트 함수 가져와야 함
  2. `WasmInstanceObject`의 `WasmIndirectFunctionTable` 내의 `targets` 포인터를 임의의 주소로 덮어씀
     - 해당 포인터는 임의의 쓰기 원시 데이터의 위치가 됨
  3. 내보낸 웹어셈블리 함수의 `function_index`를 0으로 설정
  4. `imported_function_targets`가 가리키는 내용을 임의의 값으로 덮어씀
     - 해당 값은 임의의 쓰기 원시 데이터의 내용 됨
  5. `WebAssembly.Table.prototype.set()` 호출
     - 해당 호출은 `what`을 `where`에 적음

## Patch

- 해당 취약점에 대한 패치는 두 단계로 이루어짐

1. `targets` 포인터를 힙 내(포인터 압추) 포인터로 바꿔 해당 포인턱 임의의 쓰기 원시 데이터를 얻는 데 남용되지 않도록 함
2. `targets`의 코드 진입점도 취약했기 때문에 `targets`를 원시 포인터 대신 인코딩된 포인터(ExternalPointer)를 포함하는 `ExternalPointerArray`로 변경하여 공격자가 `target`의 코드 포인터 조작 방지

## References

[Theory](https://blog.theori.io/a-deep-dive-into-v8-sandbox-escape-technique-used-in-in-the-wild-exploit-d5dcf30681d4) <br>
[Hackyboiz(해당 취약점 보고서 한글)](https://hackyboiz.github.io/2024/01/18/ogu123/cve-2023-2033/)<br>
[Chrominum](https://issues.chromium.org/issues/40063989)<br>
[Google Chrome V8 엔진을 파헤쳐보자](https://helloinyong.tistory.com/290)<br>
[V8 Heap Sandbox](https://core-research-team.github.io/2021-12-01/V8-Heap-Sandbox)<br>
[Chrome V8이란?](https://www.cloudflare.com/ko-kr/learning/serverless/glossary/what-is-chrome-v8/)
