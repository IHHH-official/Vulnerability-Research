# Ancillary Function Driver for WinSock Elevation of Privilege Vulnerability

## 작성자

이연제

## 발생일자

2023.05.05

## Summary

## Keyword

#CVE-2023-28218 #Windows #Windows_kernel #FastI/O #overflow

## Root Cause

- What is **afd.sys**?<br>

  - Microsoft Windows 운영 체제 일부. Ancillary Function Driver for Winsock의 약자
  - Fast I/O : 일반적인 I/O 작업 수행하려면 IRP(Interrupt Request Packets)가 사용되지만, 헤딩 빙밥은 커널에서 대형 객체의 초기화 및 시스템 메모리 할당과 같은 복잡한 과정이 필요하지만, Fast I/O는 IRP 생성하지 않고 장치와 직접 통신 가능하게 함
  - Windows 소켓 2 API 사용하여 TCP/IP 네트워킹 지원 => 컴퓨터가 인터넷 연결되어 데이터 주고받을 수 있게 하는 역할
  - 드라이버 충돌, 하드웨어 문제, 악성 코드 감염 등으로 인해 시스템 충돌 원인이 됨 => 블루스크린 오류(BSOD)

- FastIO Dispatcher

  - _NtDeviceIoControlFile_ system call 함수에 의해 호출된 _IopXxxControlFile_
  - _IopXxxControlFile_ 안에 FastIO Dispatch 프로세스 존재

  ```c
  __int64 __fastcall IopXxxControlFile(
          int a1,
          HANDLE Handle,
          __int64 a3,
          __int64 a4,
          unsigned __int64 a5,
          unsigned int a6,
          char *inputBuffer,
          size_t inputLength,
          char *outputBuffer,
          SIZE_T outputLength,
          char a11)
  {
      ...
      FastIoDispatch = AttachedDevice->DriverObject->FastIoDispatch; // [1]
      if ( FastIoDispatch ) // [2]
      {
          FastIoDeviceControl = FastIoDispatch->FastIoDeviceControl; // [3]
          Irp = FastIoDeviceControl;
          if ( FastIoDeviceControl )
          {
              ...
              v34 = (FastIoDeviceControl)(
                      _fileObj,
                      v29,
                      inputBuffer,
                      inputLength,
                      outputBuffer,
                      outputLength,
                      ioctlCode,
                      &v62,
                      DeviceObject);
              ...

  ```

  - 작동 과정 : *FastIODispatch*를 *DriceObject*를 통해 찾음 -> if문을 통해 *FastIODispatch*가 있다면 *FastIODispatch*로부터 _FastIoDeviceControl_ 찾고 실행
  - *afd.sys*는 *FastIoDispatch*에 등록됨
    ```
    memset64(DriverObject->MajorFunction, AfdDispatch, 0x1Cui64);
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AfdDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = AfdWskDispatchInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = &AfdEtwDispatch;
    DriverObject->FastIoDispatch = &AfdFastIoDispatch;
    ```
  - *FastDeviceControl*함수 포인터 _AdfFastIoDeviceControl_ 존재

- _AfdFastIoDeviceControl_ 함수는 7번째 인수로 전달되는 ioctlCode의 각 *IOCTL*를 처리하고 **0x120d3 (AdfSendMessage)**에서 취약점 발생
- IOCTL은 사용자가 전달한 CMSG Buffer 구조체를 커널 구조체 형식으로 복사

  ```c
  if ( userBuf )
  {
      // [1]
      if ( AfdComputeCMSGLength(userBuf, userBufSize, &cmsgSize) < 0 )
      {
          LOBYTE(ret) = 0;
          goto EXIT;
      }
      LODWORD(userBufSize) = cmsgSize;
      // [2]
      kernelBuf = ExAllocatePoolWithQuotaTag(528, cmsgSize, 0x20646641u);
      // [3]
      LODWORD(err) = AfdCopyCMSGBuffer(kernelBuf, userBuf, userBufSize);
  ...

  ```

  1. 사용자가 전달한 CMSG Buffer 구조체 파싱하고 CMSG 크기 계산
  2. 해당 크기에 대한 커널 메모리 할당
  3. _AfdCopyCMSGBuffer_ 함수 호출되어 사용자가 전달한 CMSG Buffer 구조체를 커널 메모리에 복사

- _AfdComputeCMSGLength_ 함수 분석 (for CMSG 구조체 파악)

  ```c
  __int64 __fastcall AfdComputeCMSGLength(unsigned int *userBuf, unsigned int userBufSize, _DWORD *pCmsgSize)
  {
      unsigned int totalSize; // r9d
      unsigned int chunkSize; // r10d
      unsigned int alignedSize; // eax
      ...
      for ( totalSize = 0; userBufSize >= 0xC; /**/ )
      {
          chunkSize = *userBuf;
          alignedSize = (*userBuf + 3) & 0xFFFFFFFC;
          if ( userBufSize < alignedSize )
              return 0xC000000Di64;
          userBufSize -= alignedSize;
          if ( (userBuf + alignedSize) < userBuf )
              return 0xC000000Di64;
          userBuf = (userBuf + alignedSize);
          ...
          if ( chunkSize < 0xC
          || chunkSize - 12 + 16 < chunkSize - 12
          || totalSize + ((chunkSize - 12 + 23) & 0xFFFFFFF8) < totalSize )
          {
          return 0xC000000Di64;
          }
          totalSize += (chunkSize - 12 + 23) & 0xFFFFFFF8
      }
      *pCmsgSize = totalSize;
      ...

  ```

  - 해당 함수는 사용자가 전달한 포인터 userBuf에서 chunkSize 값을 읽고, 사이즈 값만큼 userBuf 포인터 값 증가시키는 과정을 userBufSize만큼 반복
  - _AfdCopyCMSGBuffer_ 함수는 *AfdComputeCMSGLength*에 의해 계산된 cmsgSize로 할당된 커널 메모리로 복사

- *AfdCopyCMSGBuffer*함수
  ```c
  __int64 __fastcall AfdCopyCMSGBuffer(__int64 kernelBuf, unsigned int *userBuf, unsigned int cmsgSize)
  {
      unsigned int sizeRemain;
      __int64 userChunkSize;
      __int64 kernelChunkSize;
      unsigned int alignedChunkSize;
      ...
      while ( 1 )
      {
      userChunkSize = *userBuf;
      ...
      kernelChunkSize = userChunkSize + 4;
      ...

      alignedChunkSize = (kernelChunkSize + 7) & 0xFFFFFFF8; // [1]
      if ( sizeRemain < alignedChunkSize ) // [2]
          return 0i64;
      sizeRemain -= alignedChunkSize;
      memmove(kernelBuf + 16, userBuf + 3, userChunkSize - 12);
      ...
      }
      ...
  ```
  - 해당 함수는 for문을 통해 CMSG chunk를 *memmove*를 통해 커널 메모리로 복사
  - 32비트 user process에서 전달된 CMSG 구조체를 64비트 커널 메모리에 복사하기 때문에 청크 사이즈에 추가적인 정렬 작업 필요
  - [1]에서 kernelChunkSize 변수에 대한 8바이트 정렬로 인해 **오버플로우 발생**
    - 사용자가 청크 크기를 0xfffffff5에서 0xfffffffb 사이 값을 전달하면 *alignedChunkSize*가 0이 되어 [2]를 항상 통과하게 됨

## Exploit

- 위에서 언급했던 것처럼 사용자가 특정 값을 전달하면 오버플로우 발생될 수 있음
- 취약점 공격 시 고려사항

  1. 오버플로우된 청크 사이즈 : Windows heap allocator의 메모리 풀링(memeory pooling) 때문에 오버플로우 발생하여 덮어쓸 객체 크기와 오버플로우 일으킨 청크 사이즈가 유사해야함

     ```c
     if ( userBuf )
     {
         // [1]
         if ( AfdComputeCMSGLength(userBuf, userBufSize, &cmsgSize) < 0 )
         {
             LOBYTE(ret) = 0;
             goto EXIT;
         }
         LODWORD(userBufSize) = cmsgSize;
         // [2]
         kernelBuf = ExAllocatePoolWithQuotaTag(528, cmsgSize, 0x20646641u);
         // [3]
         LODWORD(err) = AfdCopyCMSGBuffer(kernelBuf, userBuf, userBufSize);
         ...

     ```

     - [1]과 [3] 사이 userBuf에 저장된 청크 사이즈 조작해서 [3]에서 정수 오버플로우 발생시키고, [2]에서 임의 크기의 힙 버퍼 할당

  2. 오버플로우 크기 : 원하는 크기로 오버플로우 해야 신뢰성 있는 공격 수행 가능

     ```c
      ...
     userChunkSize = *userBuf;
     ...
     kernelChunkSize = userChunkSize + 4;
     ...
     alignedChunkSize = (kernelChunkSize + 7) & 0xFFFFFFF8; // [1]
     ...
     memmove(kernelBuf + 16, userBuf + 3, userChunkSize - 12);

     ```

     - _AfdCopyCMSHBuffer_ 함수에서 _memmove_ 통해 오버플로우된 크기 = userChunkSize - 12 => userChunkSize + 4 + 7이 4바이트 정수를 오버플로우해야하므로 0xffffffe9에서 0xffffffef 사이 값을 넣어야함.

## Patch

```c
__int64 __fastcall AfdCopyCMSGBuffer(size_t *pResult, size_t a2, ULONG *a3, ULONG a4)
{
    ...
    if ( RtlULongSub(userChunkSize, 0xCu, &v14) < 0 )
      break;
    copyBytes = v14;
    if ( RtlSizeTAdd(v14, 0x10ui64, kernelBuf) < 0
      || (int)RtlSizeTAlignUp(*kernelBuf, 16i64, &Subtrahend) < 0
      || RtlSizeTSub(Minuend, Subtrahend, &Minuend) < 0 )
    {
      break;
    }
    ...
    memmove(kernelBuf + 2, userBuf, copyBytes);
    ...
}
```

## References

[theori](https://blog.theori.io/exploiting-windows-kernel-wild-copy-with-user-fault-handling-cve-2023-28218-89f5189d0926)
